### 1.	Что описывает и показывает Big O нотация как высчитывается , что фактически измеряется, привести примеры
**Big O нотация** — это математическая концепция, используемая в информатике для описания **асимптотической сложности алгоритмов**. Она показывает, как время выполнения алгоритма или потребление памяти **растут** с увеличением размера входных данных (обозначаемого как `n`). Big O фокусируется на **наихудшем сценарии** и игнорирует константы и менее значимые члены, оставляя только доминирующую функцию.

---

### **Как вычисляется Big O:**
1. **Определите базовые операции** (например, сравнения, циклы, присваивания).  
2. **Выразите их количество** в зависимости от `n`.  
3. **Упростите выражение**, оставив только самый быстрорастущий член.  
   - Константы игнорируются: `O(5n) → O(n)`.  
   - Младшие степени игнорируются: `O(n² + 3n) → O(n²)`.  

---

### **Что измеряет Big O:**
- **Временная сложность** — количество операций в зависимости от `n`.  
- **Пространственная сложность** — объем используемой памяти в зависимости от `n`.  

---

### **Примеры на Java**

#### **1. O(1) — Константная сложность**  
Доступ к элементу массива по индексу:  
```java
int[] arr = {1, 2, 3, 4, 5};
int x = arr[2]; // Всегда 1 операция, независимо от размера массива.
```

#### **2. O(n) — Линейная сложность**  
Линейный поиск в массиве:  
```java
int findElement(int[] arr, int target) {
    for (int num : arr) { // n итераций
        if (num == target) return num;
    }
    return -1;
}
```

#### **3. O(n²) — Квадратичная сложность**  
Сортировка пузырьком:  
```java
void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length; i++) { // n итераций
        for (int j = 0; j < arr.length - 1; j++) { // n итераций
            if (arr[j] > arr[j + 1]) {
                // swap
            }
        }
    }
}
```

#### **4. O(log n) — Логарифмическая сложность**  
Бинарный поиск:  
```java
int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
        // На каждом шаге массив уменьшается вдвое.
    }
    return -1;
}
```

#### **5. O(2ⁿ) — Экспоненциальная сложность**  
Рекурсивное вычисление чисел Фибоначчи:  
```java
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2); // Два рекурсивных вызова на каждом шаге.
}
```

---

### **Иерархия сложностей (от лучшей к худшей):**  
1. **O(1)** — Константная  
2. **O(log n)** — Логарифмическая  
3. **O(n)** — Линейная  
4. **O(n log n)** — Линейно-логарифмическая  
5. **O(n²)** — Квадратичная  
6. **O(2ⁿ)** — Экспоненциальная  

---

### **Почему константы не важны?**  
При больших `n` вклад констант и младших членов становится незначительным. Например, для `n = 1000`:  
- `O(1000n) = 1,000,000` операций.  
- `O(n²) = 1,000,000` операций.  
Но при `n = 10,000`:  
- `O(1000n) = 10,000,000`.  
- `O(n²) = 100,000,000` (растет значительно быстрее).  

---

Big O помогает выбирать оптимальные алгоритмы для больших данных, оценивая их эффективность в теории.
---
---
### 2.	Основные алгоритмы сортировки знать/поимать принцип работы
Основные алгоритмы сортировки в Java: принципы работы и реализация.

---

### 1. **Пузырьковая сортировка (Bubble Sort)**
**Принцип**:  
Сравнивает соседние элементы и меняет их местами, если они в неправильном порядке. За каждый проход наибольший элемент «всплывает» в конец массива.

**Код**:
```java
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    boolean swapped;
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        if (!swapped) break; // Оптимизация: выход при отсутствии перестановок
    }
}
```

---

### 2. **Сортировка выбором (Selection Sort)**
**Принцип**:  
Находит минимальный элемент в неотсортированной части массива и перемещает его в начало. Делит массив на отсортированную (слева) и неотсортированную (справа) части.

**Код**:
```java
public static void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```

---

### 3. **Сортировка вставками (Insertion Sort)**
**Принцип**:  
Берёт элемент из неотсортированной части и вставляет его в правильную позицию в отсортированной части массива. Начинается со второго элемента.

**Код**:
```java
public static void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

---

### 4. **Быстрая сортировка (Quick Sort)**
**Принцип**:  
Использует стратегию «разделяй и властвуй». Выбирает опорный элемент, разделяет массив на элементы меньше и больше опорного, рекурсивно сортирует подмассивы.

**Код**:
```java
public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high); // Индекс опорного элемента
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high]; // Опорный элемент (последний)
    int i = low - 1; // Индекс для элементов меньше опорного
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    // Перемещаем опорный элемент на место
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}
```

---

### 5. **Сортировка слиянием (Merge Sort)**
**Принцип**:  
Делит массив на две половины, рекурсивно сортирует каждую, затем объединяет их в один отсортированный массив.

**Код**:
```java
public static void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

private static void merge(int[] arr, int left, int mid, int right) {
    // Создаём временные массивы
    int[] L = Arrays.copyOfRange(arr, left, mid + 1);
    int[] R = Arrays.copyOfRange(arr, mid + 1, right + 1);
    
    int i = 0, j = 0, k = left;
    while (i < L.length && j < R.length) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    // Дописываем оставшиеся элементы
    while (i < L.length) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < R.length) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
```

---

### Сравнение алгоритмов
| Алгоритм         | Сложность (в среднем) | Сложность (в худшем) | Память     |
|------------------|-----------------------|----------------------|------------|
| Пузырьковая      | O(n²)                 | O(n²)                | O(1)       |
| Выбором          | O(n²)                 | O(n²)                | O(1)       |
| Вставками        | O(n²)                 | O(n²)                | O(1)       |
| Быстрая          | O(n log n)            | O(n²)                | O(log n)   |
| Слиянием         | O(n log n)            | O(n log n)           | O(n)       |

---

**Пример использования**:
```java
public static void main(String[] args) {
    int[] arr = {5, 3, 8, 4, 2};
    bubbleSort(arr);
    System.out.println(Arrays.toString(arr)); // [2, 3, 4, 5, 8]
}
```
---
---
### 3.	пузырьковая сортировка, сложность, что по памяти
**Пузырьковая сортировка** (Bubble Sort) — это простой алгоритм сортировки, который **работает "на месте"** (in-place), то есть **не требует дополнительной памяти** для хранения промежуточных данных, кроме небольшого количества временных переменных. 

---

### **Сложность по памяти (Space Complexity):**
- **Пространственная сложность:** **O(1)** (константная).  
  Алгоритм использует только **фиксированное количество дополнительной памяти** (например, переменные для временного хранения значений при обмене элементов). Это не зависит от размера входного массива `n`.

---

### **Пример на Java:**
```java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Обмен элементов (требует O(1) дополнительной памяти)
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            // Если обменов не было, массив уже отсортирован
            if (!swapped) break;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        bubbleSort(arr);
        System.out.println("Отсортированный массив: " + Arrays.toString(arr));
    }
}
```

---

### **Детали:**
1. **In-place алгоритм:**  
   - Все операции выполняются **на исходном массиве** без создания копий.  
   - Для обмена элементов используется **одна временная переменная** (`temp`), что и дает **O(1)** по памяти.

2. **Временная сложность:**  
   - **Лучший случай:** O(n) (если массив уже отсортирован).  
   - **Средний и худший случаи:** O(n²) (из-за вложенных циклов).

---

### **Сравнение с другими алгоритмами:**
| Алгоритм         | Пространственная сложность | Временная сложность (худший случай) |
|-------------------|-----------------------------|--------------------------------------|
| Пузырьковая       | **O(1)**                    | O(n²)                                |
| Быстрая сортировка| O(log n) (стек вызовов)     | O(n²)                                |
| Сортировка слиянием| O(n)                       | O(n log n)                           |
| Сортировка вставками| O(1)                      | O(n²)                                |

---

### **Почему важно знать сложность по памяти?**
- **Эффективность:** Алгоритмы с **O(1)** по памяти подходят для систем с ограниченными ресурсами (например, встроенные устройства).  
- **Оптимизация:** Если данные занимают большой объем, in-place алгоритмы избегают копирования массивов, что экономит память.

**Пузырьковая сортировка** — не самый эффективный алгоритм по времени, но его простота и минимальные требования к памяти делают его полезным для учебных целей или для очень малых массивов.
---
---
### 4.	сортировка выбором, сложность, что по памяти
5.	сортировка вставкой, сложность, что по памяти
6.	быстрая сортировка, сложность, что по памяти
7.	сортировка слиянием, сложность, что по памяти
8.	жадный алгоритм
9.	бинарный поиск
10.	Алгоритмы поиска пути: обход в глубину, обход в ширину
11.	какие структуры данных в знаете
12.	массивы достоинства недостатки
13.	связанные списки, достоинства недостатки временная сложность добавления/поиск/удаления элемента
14.	стэк, достоинства недостатки временная сложность добавления/поиск/удаления элемента
15.	очередь, достоинства недостатки временная сложность добавления/поиск/удаления элемента
16.	деревья достоинства недостатки временная сложность добавления/поиск/удаления элемента
17.	На какие основные группы можно поделить типы данных?
18.	Какие примитивные типы вы знаете?
19.	Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?
20.	Какими значениями инициализируются переменные по умолчанию?
21.	Как передается значение переменной (по ссылке/значению)?
22.	Что вы знаете про классы обертки
23.	Определение коллекции
24.	Преимущества использования коллекций
25.	Какие объекты можно хранить в коллекциях
26.	Иерархия коллекций
27.	Отличия вектора от ArrayList
28.	Что знаете об коллекциях типа List как доб. элемент\расширяется коллекция
29.	Что знаете об коллекциях типа Set
30.	Что знаете об коллекциях типа Queue
31.	Что знаете об коллекциях типа Map и их принципиальное отличие
32.	Назовите основные реализации List,Set,Map
33.	Что общего у ArrayList\LinkedList, когда какой лучше использовать
34.	Расскажите про HashSet
35.	Расскажите про TreeSet/ Как сортируются элементы
36.	Как задается порядок следования объектов в коллекции, как отсортировать коллекцию
37.	Iterator. Как его получить(). Его методы что зачем
38.	Iterable что за зверь. Что за контракт описывает
39.	Коллекция 10 элементов.Вызываю 9x Iterator.hasNext а затем Iterator.next.Что вернется
40.	Как перебрать все ключи значения Map (Можно ли через Iterable)
41.	Разница Iterator,Enumerator,ListIterator
42.	В каких случаях может быть выброшено ConcurrentModificationException
