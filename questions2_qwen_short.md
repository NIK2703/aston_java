### 1.	Что описывает и показывает Big O нотация как высчитывается , что фактически измеряется, привести примеры
Big O нотация описывает асимптотическую сложность алгоритма, измеряя количество операций (временную сложность) или использование памяти (пространственную сложность) в зависимости от размера входных данных.
### 2.	Основные алгоритмы сортировки знать/поимать принцип работы
Основные алгоритмы сортировки включают Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort и Heap Sort. Их принципы работы и реализация на Java приведены выше.
### 3.	пузырьковая сортировка, сложность, что по памяти
Пузырьковая сортировка имеет временную сложность **O(n²)** в худшем и среднем случае, и **O(n)** в лучшем случае (с оптимизацией). Пространственная сложность составляет **O(1)**, так как алгоритм работает "на месте" и использует только фиксированное количество дополнительной памяти.
### 4.	сортировка выбором, сложность, что по памяти
Сортировка выбором имеет временную сложность **O(n²)** во всех случаях и пространственную сложность **O(1)**, так как она работает "на месте" и использует только фиксированное количество дополнительной памяти.
### 5.	сортировка вставкой, сложность, что по памяти
Сортировка вставками имеет временную сложность **O(n²)** в худшем и среднем случае, и **O(n)** в лучшем случае. Пространственная сложность составляет **O(1)**, так как она работает "на месте" и использует только фиксированное количество дополнительной памяти.
### 6.	быстрая сортировка, сложность, что по памяти
Быстрая сортировка имеет временную сложность **O(n²)** в худшем случае и **O(n log n)** в среднем и лучшем случае. Пространственная сложность составляет **O(log n)** в среднем случае и **O(n)** в худшем случае.
### 7.	сортировка слиянием, сложность, что по памяти
Сортировка слиянием имеет временную сложность **O(n log n)** во всех случаях и пространственную сложность **O(n)** из-за использования временного массива.
### 8.	жадный алгоритм
Жадный алгоритм выбирает локально оптимальное решение на каждом шаге. Примеры реализации на Java включают задачи о размене монет, расписании мероприятий и дробном рюкзаке.
### 9.	бинарный поиск
Бинарный поиск — это алгоритм с временной сложностью **O(log n)**, который работает на отсортированных данных. Реализация на Java может быть выполнена как итеративно, так и рекурсивно.
### 10.	Алгоритмы поиска пути: обход в глубину, обход в ширину
Обход в глубину (DFS) и обход в ширину (BFS) — это два основных алгоритма для исследования графов. DFS использует стек (рекурсию), а BFS использует очередь. Оба алгоритма имеют временную сложность **O(V + E)**. Реализации на Java приведены выше.
### 11.	какие структуры данных в знаете
В Java существуют различные структуры данных, такие как массивы, списки (`ArrayList`, `LinkedList`), стеки, очереди (`Queue`, `Deque`), ассоциативные структуры (`HashMap`, `TreeMap`), деревья, графы и специализированные коллекции (`BitSet`, `WeakHashMap`).
### 12.	массивы достоинства недостатки
Массивы в Java имеют **достоинства**, такие как простота использования, высокая производительность и поддержка примитивных типов, но также обладают **недостатками**, включая фиксированный размер, риск выхода за границы и отсутствие встроенных методов. Их следует использовать, когда размер данных известен заранее и требуется быстрый доступ к элементам.
### 13.	связанные списки, достоинства недостатки временная сложность добавления/поиск/удаления элемента
Связанные списки имеют **достоинства**, такие как динамический размер и эффективная вставка/удаление, но также **недостатки**, такие как медленный доступ к элементам и больший расход памяти. Временная сложность операций: добавление/удаление в начало или конец — $ O(1) $, поиск и удаление из середины — $ O(n) $.
### 14.	стэк, достоинства недостатки временная сложность добавления/поиск/удаления элемента
Стек имеет **достоинства**, такие как простота реализации и эффективность операций добавления/удаления ($ O(1) $), но также **недостатки**, такие как ограниченная функциональность и неэффективный поиск ($ O(n) $).
### 15.	очередь, достоинства недостатки временная сложность добавления/поиск/удаления элемента
Очередь имеет **достоинства**, такие как простота реализации и эффективность операций добавления/удаления ($ O(1) $), но также **недостатки**, такие как ограниченная функциональность и неэффективный поиск ($ O(n) $).
### 16.	деревья достоинства недостатки временная сложность добавления/поиск/удаления элемента
Деревья имеют **достоинства**, такие как эффективный поиск ($ O(\log n) $ для сбалансированных деревьев) и гибкость, но также **недостатки**, такие как сложность реализации и зависимость от балансировки. Временная сложность операций зависит от типа дерева: для сбалансированных деревьев добавление, поиск и удаление выполняются за $ O(\log n) $.
### 17.	На какие основные группы можно поделить типы данных?
Типы данных в Java делятся на **примитивные**, **ссылочные**, **обёртки примитивных типов**, **специальные типы**, **коллекции** и **потоки/функциональные типы**.
### 18.	Какие примитивные типы вы знаете?
Примитивные типы данных в Java включают `byte`, `short`, `int`, `long`, `float`, `double`, `char` и `boolean`.
### 19.	Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?
В Java преобразование примитивных типов данных бывает автоматическим (безопасным) и явным (с возможной потерей данных). Логический тип (`boolean`) нельзя преобразовать в другие примитивные типы.
### 20.	Какими значениями инициализируются переменные по умолчанию?
Переменные экземпляра и статические переменные инициализируются значениями по умолчанию (`0`, `false`, `null`), а локальные переменные требуют явной инициализации. Элементы массива также инициализируются значениями по умолчанию.
### 21.	Как передается значение переменной (по ссылке/значению)?
В Java примитивные типы передаются по значению, а ссылочные типы передаются по значению ссылки.
### 22.	Что вы знаете про классы обертки
Классы-обёртки в Java (например, `Integer`, `Double`, `Boolean`) позволяют работать с примитивными типами как с объектами. Они поддерживают автоупаковку/автораспаковку, предоставляют полезные методы (например, `parseInt`, `equals`) и используются в коллекциях. Объекты-обёртки неизменяемы, а некоторые значения кэшируются для оптимизации.
### 23.	Определение коллекции
Коллекция в Java — это объект, который группирует несколько элементов в единое целое. Коллекции поддерживают динамический размер, работают только с объектами и предоставляют унифицированный интерфейс для различных типов данных. Они являются частью Java Collections Framework и включают такие интерфейсы, как `List`, `Set`, `Queue` и `Map`.
### 24.	Преимущества использования коллекций
Преимущества коллекций в Java включают динамический размер, унифицированный интерфейс, готовые методы для работы с данными, поддержку обобщений, возможность работы с `null`, интеграцию с Stream API и наличие потокобезопасных реализаций.
### 25.	Какие объекты можно хранить в коллекциях
В коллекциях Java можно хранить объекты, такие как строки, числа (через обёртки), пользовательские классы, `null` и другие коллекции. Примитивные типы хранятся через их классы-обёртки.
### 26.	Иерархия коллекций
Иерархия коллекций в Java включает интерфейсы `Collection`, `List`, `Set`, `Queue` и `Map`, а также их реализации (`ArrayList`, `HashSet`, `HashMap` и т.д.). Выбор коллекции зависит от требований к порядку, уникальности, производительности и многопоточности.
### 27.	Отличия вектора от ArrayList
Основные отличия между `Vector` и `ArrayList` заключаются в синхронизации (`Vector` синхронизирован, `ArrayList` — нет), производительности (`ArrayList` быстрее), росте размера и исторической роли (`Vector` устарел). В современных приложениях рекомендуется использовать `ArrayList`, если не требуется потокобезопасность.
### 28.	Что знаете об коллекциях типа List как доб. элемент\расширяется коллекция
В коллекциях типа `List` элементы добавляются с помощью методов `add`, а коллекция расширяется динамически. `ArrayList` расширяется путём создания нового массива, а `LinkedList` добавляет новые узлы. Выбор реализации зависит от требований к производительности и характера операций.
### 29.	Что знаете об коллекциях типа Set
Коллекции типа `Set` в Java обеспечивают хранение уникальных элементов. Основные реализации: `HashSet` (быстрый, неупорядоченный), `LinkedHashSet` (сохраняет порядок добавления) и `TreeSet` (сортирует элементы). Они используются для задач, где важна уникальность данных.
### 30.	Что знаете об коллекциях типа Queue
Коллекции типа `Queue` в Java обеспечивают хранение элементов в порядке очереди (FIFO). Основные реализации: `LinkedList` (стандартная очередь), `PriorityQueue` (очередь с приоритетом), `ArrayDeque` (двусторонняя очередь), `ConcurrentLinkedQueue` (потокобезопасная очередь) и `BlockingQueue` (блокирующая очередь). Они используются для задач управления задачами, буферизации данных и многопоточной обработки.
### 31.	Что знаете об коллекциях типа Map и их принципиальное отличие
Коллекции типа `Map` в Java хранят пары "ключ-значение". Основные реализации: `HashMap` (быстрый, неупорядоченный), `LinkedHashMap` (сохраняет порядок добавления), `TreeMap` (сортирует ключи), `Hashtable` (устаревшая потокобезопасная) и `ConcurrentHashMap` (современная потокобезопасная). Они используются для задач хранения связанных данных, таких как словари или данные о пользователях.
### 32.	Назовите основные реализации List,Set,Map
Основные реализации `List`: `ArrayList`, `LinkedList`, `Vector`, `Stack`.  
Основные реализации `Set`: `HashSet`, `LinkedHashSet`, `TreeSet`.  
Основные реализации `Map`: `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`, `ConcurrentHashMap`.
### 33.	Что общего у ArrayList\LinkedList, когда какой лучше использовать
`ArrayList` и `LinkedList` реализуют интерфейс `List` и имеют общие методы, но различаются по внутренней структуре и производительности. `ArrayList` лучше использовать для чтения данных и редких изменений, а `LinkedList` — для частых вставок/удалений, особенно в начале или середине списка.
### 34.	Расскажите про HashSet
`HashSet` в Java — это коллекция, основанная на хэш-таблице, которая не допускает дубликатов и не гарантирует порядок элементов. Она обеспечивает быстрый доступ ($ O(1) $) для операций добавления, удаления и поиска. Для сохранения порядка добавления можно использовать `LinkedHashSet`, а для сортировки — `TreeSet`.
### 35.	Расскажите про TreeSet/ Как сортируются элементы
`TreeSet` в Java — это коллекция, основанная на красно-чёрном дереве, которая хранит уникальные элементы в отсортированном порядке. Элементы сортируются в естественном порядке или в порядке, заданном компаратором. Производительность операций добавления, удаления и поиска составляет $ O(\log n) $. Для сохранения порядка добавления можно использовать `LinkedHashSet`, а для быстрого доступа — `HashSet`.
### 36.	Как задается порядок следования объектов в коллекции, как отсортировать коллекцию
Порядок следования объектов в коллекции зависит от её реализации. Для сортировки можно использовать методы `Collections.sort()`, `List.sort()`, `Arrays.sort()` или Stream API. Для пользовательских классов можно реализовать интерфейс `Comparable` или использовать компаратор.
### 37.	Iterator. Как его получить(). Его методы что зачем
`Iterator` в Java используется для обхода элементов коллекции. Его методы: `hasNext()` (проверка наличия следующего элемента), `next()` (получение следующего элемента) и `remove()` (удаление текущего элемента). Он позволяет безопасно модифицировать коллекцию во время обхода. Альтернативами являются цикл `for-each` и Stream API.
### 38.	Iterable что за зверь. Что за контракт описывает
`Iterable` в Java — это интерфейс, который описывает контракт для обхода элементов коллекции. Его основной метод — `iterator()`, который возвращает объект `Iterator`. Реализация `Iterable` позволяет использовать объекты в цикле `for-each` и методах, таких как `forEach`.
### 39.	Коллекция 10 элементов.Вызываю 9x Iterator.hasNext а затем Iterator.next.Что вернется
Первый вызов `Iterator.next()` после 9 вызовов `Iterator.hasNext()` вернёт **первый элемент коллекции**.
### 40.	Как перебрать все ключи значения Map (Можно ли через Iterable)
Для перебора ключей, значений или пар "ключ-значение" в `Map` можно использовать методы `keySet()`, `values()` и `entrySet()`, которые возвращают объекты, реализующие интерфейс `Iterable`. Таким образом, перебор возможен через цикл `for-each` или `Iterator`.
### 41.	Разница Iterator,Enumerator,ListIterator
Основные различия заключаются в функциональности:
- `Iterator` поддерживает удаление и работает с любыми коллекциями.
- `Enumeration` устарел и не поддерживает модификацию.
- `ListIterator` поддерживает двунаправленный обход и модификацию, но работает только с `List`.
### 42.	В каких случаях может быть выброшено ConcurrentModificationException
`ConcurrentModificationException` выбрасывается, если коллекция изменяется во время итерации, но не через методы итератора. Чтобы избежать этого, используйте `Iterator.remove()`, потокобезопасные коллекции или Stream API.   